__version__ = '20170718'   #yyymmdd
__author__ = 'Enrique Lopez-Rodriguez <enloro@gmail.com>'

"""Utilities for handling the interferometric mode of HyperCAT.
    
    .. automodule:: interferometry
    """

# IMPORTS
# 3rd party
import numpy as np
from astropy.modeling import models


#HyperCAT
import ioops as io


# HELPER FUNCTIONS
def uvload(filename):
    
    
    """This function read the uv points from a iofits file.
        
        Parameters
        ----------
        filename : str
            Name and direction of file to be load containgin the uv points
        
        
        Returns:
        --------
        u, v: uv points
        
        Example
        -------
        .. code-block:: python
        
        filename = '/your/folder/iofits.fits'
        u, v = uvload(filename)
        
        """
    
    ff = io.FitsFile(filename)
    
    #get uv points
    v = ff.getdata(4,'vcoord')
    u = ff.getdata(4,'ucoord')
    # create the center-symmetric points
    u_rev=-u
    v_rev=-v
    
    #combine the data set of uv points
    u = np.concatenate([u_rev,u])
    v = np.concatenate([v_rev,v])
    
    return u,v

def baseline_phase_1D(u,v):
    
    """This function obtain the baseline and phases in 1D for each uv point.
        
        Parameters
        ----------
        u, v : array
            Array with u, v points generated by uvload.
        
        
        Returns:
        --------
        BL : array
            baseline for each u v point
            
        Phi: array
            Phases for each u v point.
        
        Example
        -------
        .. code-block:: python
        
        BL, Phi = baseline_phase_1D(u,v)
        
        """
    
    BL = np.sqrt(u**2+v**2)
    Phi = np.rad2deg(np.arctan(u/v))
    
    return BL, Phi



def uvfreq2uvpixel(u,v,fftscale):
    
    """This function transform the uv frequency scales in pixels for a given clumpy image
        
        Parameters
        ----------
        u, v : arrays
            Array with u, v points generated by uvload.
        
        fftscale: float
            freqcuency scale generated by fft_pxscale
        
        Returns:
        --------
        u_px, v_px : arrays
            pixel scale for u and v points
        
        Example
        -------
        .. code-block:: python
        
        u_px, v_px = uvfreq2uvpixel(u,v,fftscale)
        
        """
    
    u_px = u/fftscale
    v_px = v/fftscale
    
    return u_px, v_px


def ima2fft(ima,abs='True'):
    
    """This function produces the FFT of the clumpy torus image.
        
        Parameters
        ----------
        ima : array
            2D clumpy model image
            
        abs : bol
            If True (default), only the module of the FFT is returned.
            If False, the complex values of the FFT is returned.
        
        Returns:
        --------
        ima_fft : array
            The absolute value of the 2D FFT.
        
        Example
        -------
        .. code-block:: python
        
        ima_fft = ima2fft(ima)
        
        """
    
    #The 2D FFT is shifted to reconstruct the image at the central position of the array.
    
    if abs == 'True':
        ima_fft = np.abs(np.fft.fftshift(np.fft.fft2(ima)))
    if abs == 'False':
        ima_fft = np.fft.fftshift(np.fft.fft2(ima))

    return ima_fft


def fft_pxscale(ima):
    
    """This function estimates the convertion from sky space to FFT space.
        
        Parameters
        ----------
        ima : array
            2D clumpy model image.
        
        Returns:
        --------
        fftscale : float
            The frequency scale in FFT space.
        
        Example
        -------
        .. code-block:: python
        
        fftscale = fft_pxscale(ima)
        
        """
    
    gridsize = ima.shape[0]
    #pixel scale of the image. This should be taken from the header of the clumpy torus image
    pxscale_mod = 0.00654641214133*1000      ## in mas
    #pxscale_mod = ima.pxscale.value
    #1D FFT of the gridsize.
    fft_freq=np.fft.fftfreq(gridsize,pxscale_mod)
    #wavelength of the clumpy torus image. This should be taken from the header of the clumpy torus image
    lam = 8.0*1E-6                            ## in um
    #lam = ima.wavelength
    #re-orginizing the 1D FFT to match with the grid.
    roll=np.floor(gridsize/2).astype("int")
    freq = np.fft.fftshift(fft_freq)
    ##
    ## pxscale -> fftscale
    fftscale=np.diff(freq)[0]           ## cycles / mas per pixel in FFT image
    mas2rad=np.deg2rad(1./3600000.)     ## mas per rad
    fftscale = fftscale/mas2rad * lam   ## meters baseline per px in FFT image at a given wavelength
    print "Pixel scale in FFT image is: ", fftscale, " m (Baseline) per pixel"
    
    return fftscale


def correlatedflux2D(ima_fft,u_px,v_px,BL,Phi,abs='True'):
    
    """This function creates the 2D correlated flux, Baseline and position angle maps
        
        Parameters
        ----------
        ima_fft : array
            2D FFT of the clumpy torus model from ima2fft
            
        u_px, v_px : array
            u and v planes in pixels
            
        BL : array
            Baseline estimated from uvplanes
        
        Phi : array
            Position angles estimated from uvplanes
        
        Returns:
        --------
        corrflux2D : array
            Correlated flux in 2D uv plane
        
        BL2D : array
            Baseline in 2D uv plane
        
        Phi2D : array
            Position angles in 2D uv plane
        
        Example
        -------
        .. code-block:: python
        
        corrflux2D = correlatedflux2D(ori_fft,u_px,v_px,BL,Phi)
        
        """
    
    a      = np.zeros([ima_fft.shape[0],ima_fft.shape[0]])
    BL2D   = np.zeros([ima_fft.shape[0],ima_fft.shape[0]])
    Phi2D  = np.zeros([ima_fft.shape[0],ima_fft.shape[0]])
    for ii in range(len(u_px)):
        vv = u_px[ii] + ima_fft.shape[0]/2
        uu = v_px[ii] + ima_fft.shape[0]/2
        a[uu,vv] = 1.
        BL2D[uu,vv] = BL[ii]
        Phi2D[uu,vv] = Phi[ii]

    if abs == 'True':
        corrflux2D = a*ima_fft
    if abs == 'False':
        corrflux2D = a*np.abs(ima_fft)

    return corrflux2D, BL2D, Phi2D


def correlatedflux1D(corrflux2D):
    
    """This function creates the 1D correlated flux map
        
        Parameters
        ----------
        corrflux2D : array
        Correlated fluxes in the 2D uv plane from correlatedflux2D
        
        Returns:
        --------
        corrflux1D : array
        Correlated flux in 1D uv plane
        
        corrflux1D_err : array
        Uncertainties of the correlated fluxes in 1D uv plane at a given baseline
        
        
        Example
        -------
        .. code-block:: python
        
        corrflux1D = correlatedflux1D(corrflux2D)
        
        """
    
    x, y = np.indices((corrflux2D.shape))
    r = np.sqrt((x - corrflux2D.shape[0]/2)**2 + (y - corrflux2D.shape[0]/2)**2)
    r = r.astype(np.int)
    
    radi = corrflux2D.shape[0]/2
    corrflux1D = np.empty(corrflux2D.shape[0]/2)
    corrflux1D_err = np.empty(corrflux2D.shape[0]/2)
    for jj in range(radi):
        n = np.where(r==jj)
        corrflux1D[jj] = np.nansum(corrflux2D[n])
        corrflux1D_err[jj] = np.nanstd(corrflux2D[n])
    return corrflux1D,corrflux1D_err
