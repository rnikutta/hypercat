__version__ = '20170719'   #yyymmdd
__author__ = 'Enrique Lopez-Rodriguez <enloro@gmail.com>'

"""Utilities for handling the interferometric mode of HyperCAT.
    
    .. automodule:: interferometry
    """

# IMPORTS
# 3rd party
import numpy as np
from astropy.modeling import models
import matplotlib.pyplot as plt


#HyperCAT
import ioops as io
import ndiminterpolation


# HELPER FUNCTIONS
def uvload(filename):
    
    """This function read the uv points from a iofits file.
        
        Parameters
        ----------
        filename : str
            Name and direction of file to be load containgin the uv points
        
        Returns:
        --------
        u, v: uv points
        
        Example
        -------
        .. code-block:: python
        
        filename = '/your/folder/iofits.fits'
        u, v = uvload(filename)
        
        """
    
    ff = io.FitsFile(filename)
    
    #get uv points
    v = ff.getdata(4,'vcoord')
    u = ff.getdata(4,'ucoord')
    # create the center-symmetric points
    u_rev=-u
    v_rev=-v
    
    #combine the data set of uv points
    u = np.concatenate([u_rev,u])
    v = np.concatenate([v_rev,v])
    
    return u,v

def baseline_phase_1D(u,v):
    
    """This function obtain the baseline and phases in 1D for each uv point.
        
        Parameters
        ----------
        u, v : array
            Array with u, v points generated by uvload.
        
        
        Returns:
        --------
        BL : array
            baseline for each u v point
            
        Phi: array
            Phases for each u v point.
        
        Example
        -------
        .. code-block:: python
        
        BL, Phi = baseline_phase_1D(u,v)
        
        """
    
    BL = np.sqrt(u**2+v**2)
    Phi = np.rad2deg(np.arctan(u/v))
    
    return BL, Phi



def uvfreq2uvpixel(u,v,fftscale):
    
    """This function transform the uv frequency scales in pixels for a given clumpy image
        
        Parameters
        ----------
        u, v : arrays
            Array with u, v points generated by uvload.
        
        fftscale: float
            freqcuency scale generated by fft_pxscale
        
        Returns:
        --------
        u_px, v_px : arrays
            pixel scale for u and v points
        
        Example
        -------
        .. code-block:: python
        
        u_px, v_px = uvfreq2uvpixel(u,v,fftscale)
        
        """
    
    u_px = u/fftscale
    v_px = v/fftscale
    
    return u_px, v_px


def ima2fft(ima,abs='True'):
    
    """This function produces the FFT of the clumpy torus image.
        
        Parameters
        ----------
        ima : array
            2D clumpy model image
            
        abs : bol
            If True (default), only the module of the FFT is returned.
            If False, the complex values of the FFT is returned.
        
        Returns:
        --------
        ima_fft : array
            The absolute value of the 2D FFT.
        
        Example
        -------
        .. code-block:: python
        
        ima_fft = ima2fft(ima)
        
        """
    
    #The 2D FFT is shifted to reconstruct the image at the central position of the array.
    ima = ima.data
    
    if abs == 'True':
        ima_fft = np.abs(np.fft.fftshift(np.fft.fft2(ima)))
    if abs == 'False':
        ima_fft = np.fft.fftshift(np.fft.fft2(ima))

    return ima_fft


def fft_pxscale(ima):
    
    """This function estimates the convertion from sky space to FFT space.
        
        Parameters
        ----------
        ima : array
            2D clumpy model image.
        
        Returns:
        --------
        fftscale : float
            The frequency scale in FFT space.
        
        Example
        -------
        .. code-block:: python
        
        fftscale = fft_pxscale(ima)
        
        """
    gridsize = ima.data.shape[0]
    #pixel scale of the image. This should be taken from the header of the clumpy torus image
    pxscale_mod = ima.pixelscale.value    #in mas
    #1D FFT of the gridsize.
    fft_freq=np.fft.fftfreq(gridsize,pxscale_mod)
    #wavelength of the clumpy torus image. This should be taken from the header of the clumpy torus image
    lam = ima.wave.value*1E-6                 #in m
    #lam = ima.wavelength
    #re-orginizing the 1D FFT to match with the grid.
    roll=np.floor(gridsize/2).astype("int")
    freq = np.fft.fftshift(fft_freq)
    ##
    ## pxscale -> fftscale
    fftscale=np.diff(freq)[0]           ## cycles / mas per pixel in FFT image
    mas2rad=np.deg2rad(1./3600000.)     ## mas per rad
    fftscale = fftscale/mas2rad * lam   ## meters baseline per px in FFT image at a given wavelength
    print "Pixel scale in FFT image is: ", fftscale, " m (Baseline) per pixel"
    
    return fftscale


def correlatedflux(ima_fft,u,v,abs='True'):
    
    """This function creates the 2D correlated flux, Baseline and position angle maps
        
        Parameters
        ----------
        ima_fft : array
            2D FFT of the clumpy torus model from ima2fft
            
        u, v : array
            u and v planes in meters
            
        Returns:
        --------
        corrflux : array
            Correlated flux in 2D uv plane
        
        BL : array
        Baseline estimated from uvplanes
        
        Phi : array
        Position angles estimated from uvplanes


        Example
        -------
        .. code-block:: python
        
           corrflux2D = correlatedflux2D(ori_fft,u_px,v_px,BL,Phi)
        
        """
    
    if abs == 'False':
        ima_fft = np.abs(ima_fft)
    
    x  = np.arange(ima_fft.shape[0])
    ip = ndiminterpolation.NdimInterpolation(ima_fft,[x,x])
    uu = u + ima_fft.shape[0]/2
    vv = v + ima_fft.shape[0]/2
    corrflux = ip(np.dstack((uu,vv)))

    BL = np.sqrt(u**2+v**2)
    Phi = np.rad2deg(np.arctan(u/v))

    return corrflux, BL, Phi

def ima_ifft(corrflux):
    
    if abs == 'True':
        ima_ifft = np.abs(np.fft.fftshift(np.fft.ifft2(corrflux2D)))
    if abs == 'False':
        ima_ifft = np.fft.fftshift(np.fft.ifft2(corrflux2D))

    return ima_ifft


################ Plotting functions ###########

def fig_uvplane(u,v):
    
    
    """This function plots the uv plane
        
        Parameters
        ----------
        u,v : arrays
            uv planes
        
        Returns:
        --------
        plot of uv plane
        
        
        Example
        -------
        .. code-block:: python
        
        fig_uvplane(u,v)
        
        """
    
    ### NOTE: we will need to add an option to plot the uv plane in BL [m], pixels or mas.
    
    plt.plot(u,v,'o')
    plt.xlabel('u')
    plt.xlim([np.max(u),np.min(u)])
    plt.ylabel('v')


def fig_corrflux1D(corrflux2D, BL2D, Phi2D):
    
    
    """This function plots the correlated flux in 1D as a funcion of baseline
        
        Parameters
        ----------
        u,v : arrays
        uv planes
        
        Returns:
        --------
        plot of uv plane
        
        
        Example
        -------
        .. code-block:: python
        
        fig_uvplane(u,v)
        
        """
    
    ### NOTE: Correlated flux needs to be in Jy or add units to change it.
    
    n_good = np.where(corrflux2D > 0)
    
    plot = plt.scatter(BL2D[n_good],corrflux2D[n_good], c = Phi2D[n_good], cmap = 'inferno')
    plt.colorbar(plot,label='PA ($^{\\circ}$)')
    plt.ylabel('Flux [Jy]')
    plt.xlabel('Baseline [m]')
    plt.ylim([0,np.max(corrflux2D[n_good])*1.2])


