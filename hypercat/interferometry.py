__version__ = '20170721'   #yyymmdd
__author__ = 'Enrique Lopez-Rodriguez <enloro@gmail.com>'

"""Utilities for handling the interferometric mode of HyperCAT.
    
    .. automodule:: interferometry
"""

# IMPORTS

# 3rd party
import numpy as np
from astropy.modeling import models
import matplotlib.pyplot as plt

#HyperCAT
import ioops as io
import ndiminterpolation

# HELPER FUNCTIONS
def uvload(filename):
    
    """Read uv points from a iofits file.
        
       Parameters
       ----------
       filename : str
           Name and direction of file to be load containgin the uv points
        
       Returns
       -------
       u, v: uv points
        
       Example
       -------
       .. code-block:: python
        
          filename = '/your/folder/file.oifits'
          u, v = uvload(filename)
        
    """
    
    ff = io.FitsFile(filename)
    
    #get uv points
    v = ff.getdata(4,'vcoord')
    u = ff.getdata(4,'ucoord')
    
    # create the center-symmetric points
    u_rev=-u
    v_rev=-v
    
    #combine the data set of uv points
    u = np.concatenate([u_rev,u])
    v = np.concatenate([v_rev,v])
    
    return u,v

def baseline_phase_1D(u,v):
    
    """Obtain baseline and phase in 1D for each uv point.
        
       Parameters
       ----------
       u, v : array
           Array with u, v points generated by uvload.
        
       Returns
       -------
       BL : array
           baseline for each u v point
            
       Phi: array
           Phases for each u v point.
        
       Example
       -------
       .. code-block:: python
        
          BL, Phi = baseline_phase_1D(u,v)
        
    """
    
    BL = np.sqrt(u**2+v**2)
    Phi = np.rad2deg(np.arctan(u/v))
    
    return BL, Phi


def uvfreq2uvpixel(u,v,fftscale):
    
    """Transform the uv frequency scales to pixels for a given image.
        
       Parameters
       ----------
       u, v : arrays
           Array with u, v points generated by uvload.
        
       fftscale: float
           freqcuency scale generated by fft_pxscale
        
       Returns
       --------
       u_px, v_px : arrays
           pixel scale for u and v points
        
       Example
       -------
       .. code-block:: python
        
          u_px, v_px = uvfreq2uvpixel(u,v,fftscale)
        
    """
    
    u_px = u/fftscale
    v_px = v/fftscale
    
    return u_px, v_px


def ima2fft(ima,abs='True'):
    
    """Compute 2-d FFT of an image.
        
       Parameters
       ----------
       ima : array
           2D clumpy model image
            
       abs : bool
           If True (default), only the module of the FFT is returned.
           If False, the complex values of the FFT is returned.
        
       Returns
       -------
       ima_fft : array
           The absolute value of the 2D FFT.
        
       Example
       -------
       .. code-block:: python
        
           ima_fft = ima2fft(ima)
        
    """
    
    #The 2D FFT is shifted to reconstruct the image at the central position of the array.
    ima = ima.data
    
    if abs == 'True':
        ima_fft = np.abs(np.fft.fftshift(np.fft.fft2(ima)))
    if abs == 'False':
        ima_fft = np.fft.fftshift(np.fft.fft2(ima))

    return ima_fft


def fft_pxscale(ima):
    
    """Compute conversion scale from sky space to FFT space.
        
       Parameters
       ----------
       ima : array
           2D clumpy model image.
        
       Returns
       -------
       fftscale : float
           The frequency scale in FFT space.
        
       Example
       -------
       .. code-block:: python
        
          fftscale = fft_pxscale(ima)
        
    """
    
    gridsize = ima.shape[0]
    #pixel scale of the image. This should be taken from the header of the clumpy torus image
    pxscale_mod = ima.pixelscale.value    #in mas
    #1D FFT of the gridsize.
    fft_freq=np.fft.fftfreq(gridsize,pxscale_mod)
    #wavelength of the clumpy torus image. This should be taken from the header of the clumpy torus image
    lam = ima.wave.value*1E-6                 #in m
    #lam = ima.wavelength
    #re-orginizing the 1D FFT to match with the grid.
    roll=np.floor(gridsize/2).astype("int")
    freq = np.fft.fftshift(fft_freq)
    ##
    ## pxscale -> fftscale
    fftscale=np.diff(freq)[0]           ## cycles / mas per pixel in FFT image
    mas2rad=np.deg2rad(1./3600000.)     ## mas per rad
    fftscale = fftscale/mas2rad * lam   ## meters baseline per px in FFT image at a given wavelength
    print "Pixel scale in FFT image is: ", fftscale, " m (Baseline) per pixel"
    
    return fftscale


def correlatedflux(ima_fft,u,v,abs='True'):
    
    """Compute 2D correlated flux, baseline and position angle map from a 2-d FFT map.
        
       Parameters
       ----------
       ima_fft : array
           2D FFT of the clumpy torus model from ima2fft
            
       u_px, v_px : array
           u and v planes in pixels
            
        Returns:
        --------
        corrflux : array
            Correlated flux in 2D uv plane
        
        BL : array
        Baseline estimated from uvplanes
        
        Phi : array
        Position angles estimated from uvplanes


        Example
        -------
        .. code-block:: python
        
           corrflux2D = correlatedflux2D(ori_fft,u_px,v_px,BL,Phi)
        
    """
    
    if abs == 'False':
        ima_fft = np.abs(ima_fft)
    
    x  = np.arange(ima_fft.shape[0])
    ip = ndiminterpolation.NdimInterpolation(ima_fft,[x,x])
    vv = u + ima_fft.shape[0]/2
    uu = v + ima_fft.shape[0]/2
    corrflux = ip(np.dstack((uu,vv)))

    BL = np.sqrt(u**2+v**2)
    Phi = np.rad2deg(np.arctan(u/v))

    return corrflux, BL, Phi



################ Plotting functions ###########

def fig_uvplane(u,v):
    
    """Plot the uv plane
        
       Parameters
       ----------
       u,v : arrays
           uv planes
        
       Returns
       -------
       Nothing.
        
       Example
       -------
       .. code-block:: python
        
          fig_uvplane(u,v)
        
    """
    
    ### NOTE: we will need to add an option to plot the uv plane in BL [m], pixels or mas.
    
    plt.plot(u,v,'o')
    plt.xlabel('u')
    plt.xlim([np.max(u),np.min(u)])
    plt.ylabel('v')


def fig_corrflux1D(corrflux2D, BL2D, Phi2D):
    
    """Plots the correlated flux in 1D as a funcion of baseline
        
       Parameters
       ----------
       u,v : arrays
       uv planes
        
       Returns
       -------
       Nothing.
        
       Example
       -------
       .. code-block:: python
        
          fig_uvplane(u,v)
        
    """
    
    ### NOTE: Correlated flux needs to be in Jy or add units to change it.
    
    n_good = np.where(corrflux2D > 0)
    
    plot = plt.scatter(BL2D[n_good],corrflux2D[n_good], c = Phi2D[n_good], cmap = 'inferno')
    plt.colorbar(plot,label='PA ($^{\\circ}$)')
    plt.ylabel('Flux [Jy]')
    plt.xlabel('Baseline [m]')
    plt.ylim([0,np.max(corrflux2D[n_good])*1.2])


